# developer experience in the app

There's code in the app that only exists to speed up the development and testing process. For example:
- anvil persistence
- anvil instance
- arbiter instance
- price process updates via app subscriptions
- switching between anvil/sandbox/production networks


This code is good and does a good job at what its supposed to do - speed up developers' ability to test and debug. However, it's integrated into the app
so closely to the core user facing code that its hard to discern what is "dev only" and what is "user facing".

We should compartmentalize the dev-x specific code into its own separate component. This has two consequences:
- developer code is explicit, making it easier to maintain and find for developers.
- non-developer code is not cluttering the production user-facing code, making it easier to maintain the user facing code.
- developer code is easier to manage.

Some methods to carry this out would be to:
- make an explicit anvil management interface.
    - Manage the instance & arguments
    - Load/save the instance
    - 1-click deploy protocols/modules/contracts & maybe run forge scripts?
    - Make the anvil instance available to connect to in the app
- make an explicit arbiter management interface.
    - Manage the instance & arguments
    - Load/save the instance
    - 1-click deploy protocols/modules/contracts & maybe run forge scripts?

Since these two are very closely related, it might make sense to make a single "anvil/arbiter" management interface.
This would also make it so that all the developer related code for these things is moved into its own separate compartment, clearing up the main app code.

Then, the main app code can be focused on what it needs to make it work, and the developer code can be focused on what it needs to make app maintenance and building faster.

In the production setting, the app is not doing protocol deployments or setup, it's just binding itself to the addresses of the already deployed systems. This is how the app code exist, and so moving the current non-production things to a dedicated developer screen gets us there.

Right now the loader does a lot of lifting for protocol deployments and setup - I think the loader will continue to do that but it can be separated better to make the developer stuff completely optional.

# protocol traits

I kind of want a trait for protocols to implement - implementing this trait would make the protocol effectively integrated into the app, it just needs the actual interface built. 

It should collapse everything that protocols have in common, but not be a general abstraction. All the unique custom stuff for each protocol should exist, but it exists outside the trait impl. The trait
would really just standardize the api in a way to makes some parts of the interface consistent.

For example, all protocols that are handling some type of financial feature generally have:
- 1+ smart contracts, which are connected in different ways.
- a way to get existing positions
- key actions that can be taken in the protocol, which emit events.

One of the challenges with protocols is matching addresses to respective abis. This is one thing the trait can maybe handle so its more straightforward to bind the addresses to respective contract interfaces.

